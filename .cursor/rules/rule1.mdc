---
description: Bug Handling Workflow Rules
alwaysApply: true
---
# Bug Handling Workflow Rules

**PURPOSE:** Systematic protocol for detecting, analyzing, and resolving ANY code bug.

**CORE PRINCIPLE:** Never guess. Research â†’ Understand â†’ Fix â†’ Verify.

---

## ğŸ¯ QUICK START: Bug Type Decision Tree

```
Bug detected â†’ What type?
â”œâ”€ Clear error + simple scope â†’ APPROACH 1: QUICK FIX âš¡ (5-10 min)
â”œâ”€ No clear cause + complex â†’ APPROACH 2: DEEP INVESTIGATION ğŸ”¬ (30-60 min)
â”œâ”€ External library/API error â†’ APPROACH 3: LIBRARY BUG ğŸ“š (15-30 min)
â”œâ”€ Slow/memory leak/performance â†’ APPROACH 4: PERFORMANCE BUG ğŸš€ (20-45 min)
â””â”€ Multiple components failing â†’ APPROACH 5: INTEGRATION BUG ğŸ”— (25-50 min)
```

---

## ğŸ“‹ THE 6-PHASE WORKFLOW

Every bug fix follows: **DETECT â†’ ISOLATE â†’ ANALYZE â†’ RESEARCH â†’ FIX â†’ VERIFY**

| Phase | Primary Tools | When to Use |
|-----|-----|-----|
| **DETECT** | `read_lints`, logs, stack traces | After code changes |
| **ISOLATE** | `find_symbol`, `get_symbols_overview`, `search_for_pattern` | Locate exact code |
| **ANALYZE** | `sequential-thinking mcp`, `find_referencing_symbols`, `read_file` (ranges) | Root cause analysis |
| **RESEARCH** | `exa_get_code_context`, `context7`, `brave_web_search`, `octocode` | Find solutions |
| **FIX** | Cursor Editor (NOT Serena) | Minimal change only |
| **VERIFY** | Terminal tests, `read_lints` | Confirm fix works |

---

## ğŸš€ APPROACH 1: QUICK FIX (Simple Bugs)

**USE WHEN:** âœ… Clear error + single file + common pattern + known library

**TOOL SEQUENCE:**
```
1. read_lints() OR terminal output â†’ Get error
2. read_file(path, startLine, endLine) â†’ 10 lines context
3. exa_get_code_context("library_name error_pattern", 2000) â†’ Quick solution
4. IF API issue: context7_resolve-library-id â†’ get-library-docs(topic="error_topic")
5. Fix in Cursor â†’ Minimal change
6. Terminal: Run tests + read_lints()
```

**EXAMPLE:** `TypeError: 'NoneType'` â†’ exa_get_code_context("python check None before iteration") â†’ Add `if result:` check â†’ Test passes âœ…

---

## ğŸ”¬ APPROACH 2: DEEP INVESTIGATION (Complex Bugs)

**USE WHEN:** âš ï¸ No clear error / Multiple files / Can't reproduce / Architectural issue

**TOOL SEQUENCE (Use PARALLEL where possible):**
```
1. sequential-thinking: "What are all possible causes?"
2. PARALLEL: get_symbols_overview(file) + find_symbol(symbol, include_body=False)
3. find_referencing_symbols(symbol, path) â†’ Trace call chain
4. sequential-thinking: "Based on call chain, where's the bug?"
5. read_file(file, start, end) â†’ Read suspicious sections only
6. PARALLEL RESEARCH:
   - brave_web_search("<tech> <symptom> debugging")
   - octocode_githubSearchCode([{keywordsToSearch: ["bug_pattern"], stars: ">500"}])
7. sequential-thinking: "What's the root cause?"
8. IF similar issue found: octocode_githubGetFileContent(matchString="fix")
9. Fix in Cursor â†’ Implement with tests
10. Comprehensive test suite
```

**EXAMPLE:** Data corruption â†’ sequential-thinking (race condition?) â†’ find_referencing_symbols â†’ Discover async calls without locks â†’ Research async patterns â†’ Fix: Add asyncio.Lock â†’ Test concurrent requests âœ…

---

## ğŸ“š APPROACH 3: LIBRARY BUG (External Dependencies)

**USE WHEN:** ğŸ“¦ Error from library / API behavior changed / Version incompatibility / Unclear docs

**TOOL SEQUENCE (CRITICAL - PARALLEL RESEARCH):**
```
1. Extract from error: library name, function, error message
2. find_symbol(your_function_calling_library, include_body=True)
3. PARALLEL RESEARCH:
   - exa_get_code_context("<library> <function> usage", 3000)
   - context7_resolve-library-id("<library>") â†’ Note ID
   - brave_web_search("<library> <error>")
   - octocode_githubSearchCode([{keywordsToSearch: ["lib", "func"], stars: ">1000"}])
4. context7_get-library-docs("/org/lib", topic="<function>") â†’ Official spec
5. COMPARE: Your usage vs examples vs official docs
6. sequential-thinking: "What's different in my usage?"
7. Fix: Align with correct pattern
8. Test: Include example from docs
```

**EXAMPLE:** `requests.ConnectionError` â†’ find_symbol shows timeout=None â†’ PARALLEL research â†’ context7 docs show timeout required â†’ Fix: timeout=30 â†’ Works âœ…

---

## ğŸš€ APPROACH 4: PERFORMANCE BUG

**USE WHEN:** ğŸŒ Too slow / ğŸ’¾ Memory leak / ğŸ“ˆ High CPU / â±ï¸ Timeout

**TOOL SEQUENCE:**
```
1. Profile: python -m cProfile / node --prof
2. Identify hot path (slow function)
3. find_symbol(slow_function, include_body=True)
4. search_for_pattern(r"for.*in.*:", path=file) â†’ Find loops
5. sequential-thinking: "O(nÂ²)? Redundant calls? Missing cache?"
6. find_referencing_symbols(slow_function) â†’ How often called?
7. PARALLEL RESEARCH:
   - exa_get_code_context("<lang> optimize <algorithm>", 4000)
   - octocode_githubSearchCode([{keywordsToSearch: ["performance", "optimize"], stars: ">1000"}])
   - brave_web_search("<lang> <operation> performance")
8. IF found pattern: octocode_githubGetFileContent â†’ Study implementation
9. Fix: Optimize (cache, better algorithm, batching)
10. Profile again â†’ Compare metrics
```

**EXAMPLE:** API 5s â†’ Profile shows N+1 query â†’ find_symbol sees loop queries â†’ exa: "sqlalchemy N+1" â†’ Fix: joinedload â†’ 0.2s (25x faster) âœ…

---

## ğŸ”— APPROACH 5: INTEGRATION BUG

**USE WHEN:** ğŸ”Œ Multi-service failure / Works alone, fails integrated / API mismatch / Data flow issue

**TOOL SEQUENCE:**
```
1. Document: "Component A sends X, Component B expects Y"
2. sequential-thinking: "Map data flow: A â†’ ? â†’ B"
3. PARALLEL: get_symbols_overview(component_a) + get_symbols_overview(component_b)
4. find_symbol(api_endpoint, include_body=True) â†’ BOTH components
5. search_for_pattern(r"api.*call|event.*emit") â†’ Find integration points
6. Compare: What A sends vs B expects
7. PARALLEL RESEARCH:
   - exa_get_code_context("<framework> API validation")
   - octocode_githubSearchCode([{keywordsToSearch: ["api", "integration", "contract"]}])
8. IF API library: context7_get-library-docs for schema
9. sequential-thinking: "Data transformation missing?"
10. Fix: Add validation/transformation layer
11. End-to-end integration test
```

**EXAMPLE:** Frontend date â†’ Backend fails â†’ find_symbol both sides â†’ Frontend sends ISO string, backend expects Unix timestamp â†’ exa: "js date to unix" â†’ Fix: date.getTime()/1000 â†’ Test passes âœ…

---

## ğŸ¯ DECISION MATRIX: Symptom â†’ Approach

| Symptom | Approach | First Tool | Why |
|-----|-----|-----|-----|
| Clear error + known library | QUICK FIX | `exa_get_code_context` | Fast solution |
| Silent failure / wrong output | DEEP INVESTIGATION | `sequential-thinking` | Need RCA |
| Library AttributeError | LIBRARY BUG | `context7_get-library-docs` | Check API |
| Slow / timeout | PERFORMANCE | Profile first | Measure bottleneck |
| Works alone, fails together | INTEGRATION | `sequential-thinking` | Map data flow |
| Dependency stack trace | LIBRARY BUG | `exa_get_code_context` | Usage examples |
| Memory leak | PERFORMANCE | `search_for_pattern` | Find leaks |
| API 400/500 error | INTEGRATION | `find_symbol` both ends | Contract mismatch |

---

## âš¡ TOOL USAGE BEST PRACTICES

### Serena MCP - Targeted Code Analysis
```python
# âŒ WRONG: Read entire file
read_file("large_file.py")  # 1000 lines!

# âœ… RIGHT: Targeted approach
get_symbols_overview("large_file.py")  # Structure
find_symbol("Class/method", include_body=True)  # Only needed code
```

### Research - Parallel Execution
```python
# âœ… RIGHT: Make multiple research calls in same tool_calls block for speed
# Combine: exa + context7 + brave + octocode simultaneously
```

### Sequential Thinking - When to Use
```python
# âœ… USE FOR: Root cause analysis, data flow mapping, complex decisions
# âŒ DON'T USE FOR: Simple bugs (overkill), obvious causes
```

### Octocode - Quality Filters
```python
# âœ… RIGHT: Specific + quality filter
githubSearchCode([{
  keywordsToSearch: ["specific_func", "fix"],  # â‰¤3 keywords
  stars: ">1000",  # Quality repos
  limit: 5
}])

# âŒ WRONG: Too generic
keywordsToSearch: ["error", "fix", "bug", "issue"]  # Too vague
```

---

## ğŸš« COMMON PITFALLS

| âŒ DON'T | âœ… DO |
|-----|-----|
| Guess without research | Use MCP tools ALWAYS |
| Read entire files | `get_symbols_overview` â†’ `find_symbol` â†’ targeted read |
| Fix symptoms only | `sequential-thinking` for root cause |
| Ignore official docs | Check `context7` for library bugs |
| Skip verification | Run tests + `read_lints` after fix |
| Over-refactor during fix | Minimal change only |
| Sequential research (slow) | PARALLEL tool calls |
| Use Serena to edit code | Use Cursor editor only |

---

## ğŸ“ VERIFICATION CHECKLIST

After every fix:
- [ ] Bug reproduced? Triggered original error?
- [ ] Root cause identified? Know WHY it happened?
- [ ] Research done? Used appropriate MCP tools?
- [ ] Minimal change? Only fixed bug, no extras?
- [ ] Tests pass? Ran test suite?
- [ ] Linter clean? No new `read_lints` errors?
- [ ] Edge cases? Tested boundaries?

---

## ğŸ“ WORKFLOW EXAMPLES BY BUG TYPE

### Import Error (QUICK FIX - 5 min)
```
read_lints â†’ "ModuleNotFoundError: pandas"
â†’ exa_get_code_context("python pandas install")
â†’ Fix: Add "pandas==2.0.0" to requirements.txt
â†’ pip install â†’ Verify âœ…
```

### Logic Bug (DEEP - 40 min)
```
Symptom: Order total incorrect
â†’ sequential-thinking: "Rounding? Tax? Discount?"
â†’ find_symbol("calculate_total") â†’ find_referencing_symbols
â†’ Discover: Discount applied twice
â†’ brave_web_search("prevent duplicate discount")
â†’ Fix: Add discount tracking flag
â†’ Test all scenarios âœ…
```

### API Error (LIBRARY - 20 min)
```
"stripe.error.InvalidRequestError"
â†’ find_symbol("process_payment", include_body=True)
â†’ PARALLEL: exa + context7_resolve + brave + octocode
â†’ context7_get-library-docs("/stripe/stripe-python", topic="payment")
â†’ Found: Missing "currency" field
â†’ Fix: Add currency="usd"
â†’ Test payment âœ…
```

### Slow Query (PERFORMANCE - 30 min)
```
API takes 5 seconds
â†’ Profile: Database query in loop (N+1)
â†’ find_symbol("get_users_with_posts")
â†’ exa_get_code_context("sqlalchemy N+1 query")
â†’ octocode: Examples with joinedload
â†’ Fix: query.options(joinedload(User.posts))
â†’ Re-profile: 0.2s (25x faster) âœ…
```

### Data Mismatch (INTEGRATION - 35 min)
```
Frontend â†’ Backend validation fails
â†’ sequential-thinking: Map data flow
â†’ find_symbol: Frontend sends ISO date, backend expects Unix timestamp
â†’ exa_get_code_context("javascript date unix timestamp")
â†’ Fix: Frontend converts date.getTime()/1000
â†’ Integration test âœ…
```

---

## ğŸ”§ EMERGENCY PROTOCOL (When Stuck 30+ Minutes)

1. **STOP** - Don't try random fixes
2. **DOCUMENT** - What tried / researched / learned
3. **sequential-thinking** - List: known / unknown / what info would unblock
4. **ASK USER** - Present findings, request: clarification / logs / expected behavior
5. **WORKAROUND** - Suggest temporary fix while investigating root cause

**Remember:** Better to ask than break working code with guesses.

---

## ğŸ“š TOOL SELECTION CHEATSHEET

| Need | Tool | Example |
|-----|-----|-----|
| Code structure | `get_symbols_overview` | Understand file layout |
| Find symbol | `find_symbol` | Locate class/function |
| Trace usage | `find_referencing_symbols` | Who calls this? |
| Pattern search | `search_for_pattern` | Find regex matches |
| Usage examples | `exa_get_code_context` | How to use API |
| Official docs | `context7_get-library-docs` | Authoritative spec |
| Real fixes | `octocode_githubSearchCode` | GitHub solutions |
| Concepts | `brave_web_search` | General research |
| Root cause | `sequential-thinking mcp` | Structured analysis |
| Edit code | Cursor Editor | Never Serena |

---

## ğŸ¯ QUICK DECISION GUIDE

**Step 1:** Read error message / symptom
**Step 2:** Check Decision Matrix (line 124) â†’ Pick approach
**Step 3:** Follow tool sequence for that approach
**Step 4:** Research with PARALLEL calls
**Step 5:** Fix with minimal change
**Step 6:** Verify with checklist (line 256)

---

**KEY REMINDERS:**
1. Research BEFORE fixing (always use MCP tools)
2. Root cause, not symptoms (use `sequential-thinking` for complex bugs)
3. Minimal changes only (no refactoring during bug fix)
4. Parallel tool calls (faster research)
5. Always verify (tests + lints)

---