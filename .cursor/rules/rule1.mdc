---
description: Bug Handling Workflow Rules
alwaysApply: true
---
# Bug Handling Workflow Rules

**PURPOSE:** Systematic methodology for identifying, analyzing, and resolving bugs efficiently.

**WHEN TO APPLY:** Errors, warnings, unexpected behavior, test failures, or any code malfunction.

**CORE PRINCIPLE:** Root Cause Analysis (RCA) - Solve problems at their source, not symptoms. Never guess; research, analyze, verify.

---

## üéØ QUICK DECISION TREE

```
Bug Detected ‚Üí Can reproduce? ‚Üí NO ‚Üí Gather info (logs, conditions)
             ‚Üì YES
Error message clear? ‚Üí YES ‚Üí Phase 2 (Locate)
             ‚Üì NO
Intermittent/flaky? ‚Üí YES ‚Üí Add logging, monitor
             ‚Üì NO
Follow 4-Phase Workflow ‚Üì
```

---

## üìã THE 4-PHASE WORKFLOW

### PHASE 1: REPRODUCE & UNDERSTAND

**Goal:** Confirm bug exists and understand scope

**Steps:**
1. **Reproduce Consistently** (‚â•3 times with same steps)
   - Document exact trigger steps
   - Note conditions: OS, browser, inputs, environment, timing
   - Try different environments (dev/staging/prod)

2. **Gather Evidence**
   - Error messages (full stack traces)
   - Logs (application + system)
   - Recent changes (git log, recent commits)
   - Environment details (versions, dependencies)

3. **Define Bug Characteristics**
   - Severity: Critical/High/Medium/Low
   - Scope: Single function/Module/System-wide
   - Type: Syntax/Logic/Runtime/Integration/Performance
   - Frequency: Always/Intermittent/Edge case

**Tools:** Cursor Diagnostics, Terminal, Git history

---

### PHASE 2: LOCATE ROOT CAUSE

**Goal:** Pinpoint exact code location causing bug

#### A. Start with Error Message/Stack Trace

```python
# Example: "AttributeError: 'NoneType' object has no attribute 'process'"

# Get overview
mcp_serena_get_symbols_overview("path/to/error_file.py")

# Find problematic symbol
mcp_serena_find_symbol(
    name_path="ClassName/method_name",
    relative_path="path/to/error_file.py",
    include_body=True
)

# Check callers (trace data flow)
mcp_serena_find_referencing_symbols(
    name_path="ClassName/method_name",
    relative_path="path/to/error_file.py"
)
```

#### B. If Error Location Unknown

```python
# Search for error patterns
mcp_serena_search_for_pattern(
    substring_pattern=r"def process.*:",
    relative_path="src/",
    paths_include_glob="*.py",
    context_lines_before=3,
    context_lines_after=3
)

# Or use Cursor Search for exact strings
```

#### C. Isolate Problem (Binary Search)
1. Comment out half of suspicious code
2. Run test/reproduce bug
3. If bug persists ‚Üí problem in active half
4. If bug disappears ‚Üí problem in commented half
5. Repeat until exact lines found

**Tools:** Serena MCP (`find_symbol`, `find_referencing_symbols`, `search_for_pattern`), Cursor Debugger

---

### PHASE 3: RESEARCH SOLUTIONS

**Goal:** Find how others solved similar issues

#### A. Parallel Research (run in same batch)

```python
# 1. General web search
mcp_brave-search_brave_web_search(
    query="[exact error] [language] [framework]",
    count=10
)

# 2. Code examples
mcp_exa_get_code_context_exa(
    query="how to fix [error type] in [framework]",
    tokensNum=3000
)

# 3. GitHub search
mcp_octocode_githubSearchCode(
    queries=[{
        "keywordsToSearch": ["error_keyword", "fix"],
        "match": "file",
        "limit": 5
    }]
)

# 4. Official docs
mcp_context7_resolve-library-id(libraryName="library-name")
mcp_context7_get-library-docs(
    context7CompatibleLibraryID="/org/project",
    topic="error handling"
)
```

**Research Checklist:**
- [ ] Stack Overflow for exact error
- [ ] GitHub Issues in relevant repos
- [ ] Official documentation
- [ ] Blog posts/tutorials

#### B. For Complex Bugs

```python
# Extract full content from promising URLs
mcp_Bright_Data_scrape_batch(urls=["url1", "url2"])  # Max 10
```

#### C. Evaluate Solutions

**Criteria:** Relevance, Recency, Authority, Completeness, Verification

**Document:**
```
SOLUTION CANDIDATES:
1. From [Source]:
   - Approach: [Description]
   - Why it works: [Root cause]
   - Confidence: High/Medium/Low
```

#### D. If No Existing Solution

1. Read official docs thoroughly (API refs, error guides, FAQs)
2. Analyze library source code (use Octocode)
3. Understand expected vs actual behavior
4. Form hypotheses (use `sequential-thinking mcp`)
5. Test each hypothesis systematically

---

### PHASE 4: IMPLEMENT & TEST FIX

**Goal:** Apply solution without introducing new bugs

#### A. Pre-Implementation

```python
# Check impact first
mcp_serena_think_about_task_adherence()
mcp_serena_find_referencing_symbols(name, path)  # See all callers
```

**Checklist:**
- [ ] Understand root cause (not symptoms)
- [ ] Clear solution approach
- [ ] Know which files/functions to modify
- [ ] Identified all affected code paths
- [ ] Backed up state (`git stash` or commit)

#### B. Implementation Best Practices

1. **Minimal Changes** - Only what's necessary, one bug = one fix

2. **Add Defensive Code**
```python
# Add null checks, validation, better error messages
if data is None:
    logger.error("Data is None in process_data()")
    raise ValueError("Expected data, got None")
```

3. **Add Comments** - Explain WHY (root cause + solution), not WHAT

4. **Follow Code Style** - Match project conventions

#### C. Testing Levels

```bash
# 1. Unit test
pytest tests/test_module.py::test_case -v

# 2. Reproduce original bug (should not occur)

# 3. Regression test
pytest tests/ -v

# 4. Check linter
read_lints(["path/to/file.py"])

# 5. Manual testing (happy path + edge cases)
```

---

## üõ†Ô∏è TOOL DECISION MATRIX

| Task | Tool | Usage |
|---|---|---|
| Find error location | Serena | `get_symbols_overview` ‚Üí `find_symbol` |
| Trace code flow | Serena | `find_referencing_symbols` |
| Pattern search | Serena | `search_for_pattern` |
| Research solutions | Brave + Exa | Web + code search |
| Deep extraction | Bright Data | `scrape_batch` |
| Check docs | Context7 | `get-library-docs` |
| GitHub examples | Octocode | `githubSearchCode` |
| Run tests | Terminal | `pytest`, `npm test` |
| Check errors | Cursor | Diagnostics Panel + `read_lints` |
| Debug execution | Cursor | Breakpoints + Step Through |

---

## ‚úÖ BEST PRACTICES

### DO's ‚úÖ
1. Always reproduce first
2. Use version control
3. Test thoroughly (unit + integration + manual)
4. Document root cause
5. Use systematic approach
6. Verify assumptions with evidence
7. Check recent changes (git log)
8. Read error messages carefully

### DON'Ts ‚ùå
1. Don't guess and commit
2. Don't fix symptoms only
3. Don't skip testing
4. Don't make multiple changes at once
5. Don't ignore warnings
6. Don't rush
7. Don't work in isolation

---

## üéì REAL-WORLD EXAMPLE

**Bug:** "TypeError: Cannot read property 'map' of undefined"

**Phase 1: Reproduce**
- Navigate to /dashboard ‚Üí Click "Load Data" ‚Üí Crash (100%)
- Stack trace: `dashboard.js:45`

**Phase 2: Locate**
```python
get_symbols_overview("src/dashboard.js")
find_symbol("renderChart", "src/dashboard.js", include_body=True)
# Line 45: return data.map(item => ...)

find_referencing_symbols("renderChart", "src/dashboard.js")
# Called from loadData()

find_symbol("loadData", "src/dashboard.js", include_body=True)
# Calls API ‚Üí immediately calls renderChart()
# ROOT CAUSE: No null check! API returns null when no data
```

**Phase 3: Research**
```python
brave_web_search("javascript cannot read property map undefined fix")
exa_get_code_context_exa("javascript null check before map")
# Result: Add null/array validation before map()
```

**Phase 4: Fix & Test**
```javascript
// Before:
async function loadData() {
  const data = await fetchDataFromAPI();
  renderChart(data);  // Crash if null
}

// After:
async function loadData() {
  const data = await fetchDataFromAPI();
  if (!data || !Array.isArray(data)) {
    showEmptyState();
    return;
  }
  renderChart(data);
}
```

**Testing:** ‚úì Null case works ‚úì Valid data works ‚úì Tests pass

**Commit:**
```
fix: handle null data from API

Root Cause: API returns null when no records
Solution: Added null check before renderChart()
Tested: All cases pass
```

---

## üö® SPECIAL CASES

**Intermittent Bugs:** Add logging, monitor patterns, use sequential-thinking MCP

**Performance Bugs:** Profile (DevTools, cProfile), identify bottlenecks, benchmark

**Integration Bugs:** Test independently, check network logs, verify configs

**No Error Message:** Add logging, binary search, use debugger

---

## üí° KEY PRINCIPLES

**Golden Rule:** "The bug is always in the code you're sure is correct."

**Scientific Method:**
1. Observe (reproduce)
2. Hypothesize (theories)
3. Test (verify)
4. Conclude (root cause)
5. Verify (fix works)

**Communication:** Always explain to user:
- What the bug was
- Why it happened (root cause)
- How you fixed it

---

## üìù COMPLETION CHECKLIST

Before declaring "bug fixed":
- [ ] Bug consistently reproducible
- [ ] Root cause identified (not symptoms)
- [ ] Research completed
- [ ] Minimal changes made
- [ ] Original bug no longer occurs
- [ ] Tests pass
- [ ] No new linter errors
- [ ] Code documented (comments + commit)

---

**REMEMBER:** Debugging improves with practice. Stay systematic, verify with evidence, and communicate clearly! üöÄ